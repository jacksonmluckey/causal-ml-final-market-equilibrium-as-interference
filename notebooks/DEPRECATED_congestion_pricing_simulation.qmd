---
format:
    html:
        embed-resources: true
---

# Adapting "Experimenting in Equilibrium" to Congestion Pricing

The paper explicitly mentions congestion pricing as a natural application of its methodology. [^1] Let me show you how to adapt the framework.

---

## Key Mapping: Marketplace → Road Network

| Marketplace Model | Congestion Pricing Model |
|-------------------|--------------------------|
| Suppliers (drivers on platform) | Drivers considering using the road |
| Payment p (paid to supplier) | Toll p (charged to driver, so negative) |
| Match rate ω(d/s) | Travel time/congestion cost T(n) |
| Outside option | Alternative route or mode of transport |
| Platform profit | Social welfare or toll revenue |

**The core insight remains the same**: All interference between drivers is channeled through a single aggregate statistic—**congestion**—so mean-field modeling captures the effect. [^1]

---

## Step 1: The Congestion Model

```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import brentq

np.random.seed(42)

# =============================================================================
# STEP 1: Define the Congestion Model
# =============================================================================

class RoadNetwork:
    """
    A road network where:
    - n potential drivers decide whether to use a tolled road
    - Travel time increases with the number of drivers (congestion)
    - Each driver has a trip value (willingness to pay) and time cost
    
    The key interference mechanism: more drivers → more congestion → 
    some drivers switch to alternatives.
    """
    
    def __init__(self, n_drivers=1000, free_flow_time=20, capacity=600):
        self.n = n_drivers
        self.free_flow_time = free_flow_time  # minutes, when road is empty
        self.capacity = capacity  # practical capacity of the road
        
    def travel_time(self, n_drivers_on_road):
        """
        BPR (Bureau of Public Roads) congestion function:
        T(n) = T_0 × [1 + α × (n/C)^β]
        
        This is the standard model used in transportation economics.
        - T_0: free-flow travel time
        - C: road capacity
        - α, β: calibration parameters (typically α=0.15, β=4)
        """
        alpha = 0.15
        beta = 4
        
        if n_drivers_on_road <= 0:
            return self.free_flow_time
        
        volume_ratio = n_drivers_on_road / self.capacity
        return self.free_flow_time * (1 + alpha * (volume_ratio ** beta))
    
    def travel_time_derivative(self, n_drivers_on_road):
        """
        Derivative of travel time with respect to number of drivers.
        dT/dn = T_0 × α × β × (n/C)^(β-1) × (1/C)
        """
        alpha = 0.15
        beta = 4
        
        if n_drivers_on_road <= 0:
            return 0
        
        volume_ratio = n_drivers_on_road / self.capacity
        return self.free_flow_time * alpha * beta * (volume_ratio ** (beta - 1)) / self.capacity
    
    def driver_utility(self, trip_value, toll, travel_time, value_of_time=1.0):
        """
        Driver utility from taking the tolled road:
        U = V - p - γ × T(n)
        
        where:
        - V: value of completing the trip via this road
        - p: toll paid
        - γ: value of time (converts minutes to dollars)
        - T(n): travel time given n drivers
        """
        return trip_value - toll - value_of_time * travel_time
    
    def alternative_utility(self, trip_value):
        """
        Utility from taking alternative (other road, public transit, not traveling).
        
        For simplicity, assume alternative has fixed travel time but no toll.
        Different drivers have different alternatives (captured in trip_value distribution).
        """
        alternative_time = 35  # Alternative is slower but free
        value_of_time = 1.0
        return trip_value - value_of_time * alternative_time

# Create road network
road = RoadNetwork(n_drivers=1000, free_flow_time=20, capacity=600)

# Visualize congestion function
driver_counts = np.linspace(0, 1000, 100)
travel_times = [road.travel_time(n) for n in driver_counts]

fig, axes = plt.subplots(1, 2, figsize=(12, 4))

axes[0].plot(driver_counts, travel_times, 'b-', linewidth=2)
axes[0].axhline(y=35, color='r', linestyle='--', label='Alternative route time')
axes[0].axvline(x=road.capacity, color='g', linestyle=':', label='Road capacity')
axes[0].set_xlabel('Number of Drivers on Road')
axes[0].set_ylabel('Travel Time (minutes)')
axes[0].set_title('Congestion Function (BPR Model)')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Show marginal congestion cost (externality)
marginal_costs = [road.travel_time_derivative(n) * n for n in driver_counts]
axes[1].plot(driver_counts, marginal_costs, 'm-', linewidth=2)
axes[1].set_xlabel('Number of Drivers on Road')
axes[1].set_ylabel('Total Externality Cost ($)')
axes[1].set_title('Congestion Externality (Cost Imposed on Others)')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("Key insight: Each additional driver slows down ALL other drivers.")
print("This externality is why tolls can improve social welfare.")
```

---

## Step 2: Computing the Traffic Equilibrium

```{python}
# =============================================================================
# STEP 2: Computing the Traffic Equilibrium (Wardrop Equilibrium)
# =============================================================================

def compute_traffic_equilibrium(road, toll, trip_values, value_of_time=1.0):
    """
    Find the equilibrium number of drivers on the tolled road.
    
    At equilibrium: marginal driver is indifferent between tolled road and alternative.
    
    This is analogous to the supply equilibrium in the marketplace model.
    """
    n = road.n
    
    # Sort drivers by trip value (highest value drivers most likely to use road)
    sorted_indices = np.argsort(trip_values)[::-1]  # Descending order
    
    # Binary search for equilibrium: find n* such that n*-th highest value driver
    # is indifferent between road and alternative
    
    def excess_demand(n_on_road):
        """
        How many drivers WANT to use the road given n are already on it.
        At equilibrium, this equals n_on_road.
        """
        if n_on_road <= 0:
            n_on_road = 1  # Avoid edge case
            
        travel_time = road.travel_time(n_on_road)
        
        # Count drivers who prefer tolled road
        want_to_use = 0
        for i in range(n):
            utility_road = road.driver_utility(trip_values[i], toll, travel_time, value_of_time)
            utility_alt = road.alternative_utility(trip_values[i])
            
            if utility_road >= utility_alt:
                want_to_use += 1
        
        return want_to_use - n_on_road
    
    # Find equilibrium via fixed-point iteration
    n_on_road = road.capacity // 2  # Initial guess
    
    for _ in range(100):
        travel_time = road.travel_time(n_on_road)
        
        # Count how many want to use road at current congestion level
        want_to_use = 0
        for v in trip_values:
            utility_road = road.driver_utility(v, toll, travel_time, value_of_time)
            utility_alt = road.alternative_utility(v)
            if utility_road >= utility_alt:
                want_to_use += 1
        
        # Update with damping
        new_n = 0.7 * n_on_road + 0.3 * want_to_use
        
        if abs(new_n - n_on_road) < 0.5:
            break
        n_on_road = new_n
    
    n_on_road = int(round(n_on_road))
    final_travel_time = road.travel_time(n_on_road)
    
    return n_on_road, final_travel_time

# Generate heterogeneous trip values
# Higher values = more valuable trips (e.g., business travelers, urgent trips)
trip_values = np.random.exponential(scale=25, size=road.n) + 10

# Compute equilibria for different toll levels
tolls = np.linspace(0, 20, 25)
equilibria = []

for toll in tolls:
    n_eq, tt_eq = compute_traffic_equilibrium(road, toll, trip_values)
    
    # Compute social metrics
    toll_revenue = toll * n_eq
    total_travel_time_cost = tt_eq * n_eq  # Assuming value of time = 1
    
    # Social welfare (simplified): sum of utilities
    # For drivers on road: V - toll - travel_time
    # For drivers on alternative: alternative_utility
    
    equilibria.append({
        'toll': toll,
        'n_on_road': n_eq,
        'travel_time': tt_eq,
        'toll_revenue': toll_revenue,
        'total_time_cost': total_travel_time_cost
    })

# Visualize
fig, axes = plt.subplots(1, 3, figsize=(14, 4))

axes[0].plot(tolls, [e['n_on_road'] for e in equilibria], 'b-', linewidth=2)
axes[0].set_xlabel('Toll ($)')
axes[0].set_ylabel('Drivers on Road')
axes[0].set_title('Demand vs Toll')
axes[0].grid(True, alpha=0.3)

axes[1].plot(tolls, [e['travel_time'] for e in equilibria], 'r-', linewidth=2)
axes[1].set_xlabel('Toll ($)')
axes[1].set_ylabel('Travel Time (min)')
axes[1].set_title('Congestion vs Toll')
axes[1].grid(True, alpha=0.3)

axes[2].plot(tolls, [e['toll_revenue'] for e in equilibria], 'g-', linewidth=2)
axes[2].set_xlabel('Toll ($)')
axes[2].set_ylabel('Revenue ($)')
axes[2].set_title('Toll Revenue')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("As toll increases: fewer drivers → less congestion → faster travel")
print("But: some drivers are priced out who would benefit from using the road")
```

---

## Step 3: The Interference Problem in Congestion Pricing

The paper specifically notes this problem: [^1]

> *"If we raise the tolls on a small subset of the drivers and hence discourage them from going on the road, those whose tolls remain unchanged may experience less congestion and hence be inclined to drive more."*

```{python}
# =============================================================================
# STEP 3: Demonstrating the Interference Problem
# =============================================================================

def naive_toll_experiment(road, base_toll, toll_increase, trip_values):
    """
    Naive A/B test: randomly assign some drivers to higher toll.
    
    Problem: Treated drivers who stop using road reduce congestion for control!
    This makes the control group MORE likely to use the road, biasing our estimate.
    """
    n = road.n
    
    # Random assignment
    treatment_mask = np.random.choice([True, False], size=n)
    tolls = np.where(treatment_mask, base_toll + toll_increase, base_toll)
    
    # Find equilibrium with heterogeneous tolls
    n_on_road = road.capacity // 2
    
    for _ in range(100):
        travel_time = road.travel_time(n_on_road)
        
        uses_road = []
        for i in range(n):
            utility_road = road.driver_utility(trip_values[i], tolls[i], travel_time)
            utility_alt = road.alternative_utility(trip_values[i])
            uses_road.append(utility_road >= utility_alt)
        
        uses_road = np.array(uses_road)
        new_n = np.sum(uses_road)
        
        if abs(new_n - n_on_road) < 0.5:
            break
        n_on_road = 0.7 * n_on_road + 0.3 * new_n
    
    # Measure usage rates
    treatment_usage = np.mean(uses_road[treatment_mask])
    control_usage = np.mean(uses_road[~treatment_mask])
    
    naive_effect = treatment_usage - control_usage
    
    return naive_effect, treatment_usage, control_usage, travel_time

# Compare naive estimate to true effect
base_toll = 5.0
toll_increase = 3.0

# Naive A/B test
naive_eff, treat_rate, ctrl_rate, _ = naive_toll_experiment(
    road, base_toll, toll_increase, trip_values
)

# True effect: what happens when EVERYONE gets the toll increase?
n_base, _ = compute_traffic_equilibrium(road, base_toll, trip_values)
n_increased, _ = compute_traffic_equilibrium(road, base_toll + toll_increase, trip_values)
true_effect = (n_increased - n_base) / road.n

print("Naive A/B Test Results:")
print("=" * 50)
print("Treatment group usage rate: {:.1%}".format(treat_rate))
print("Control group usage rate: {:.1%}".format(ctrl_rate))
print("Naive estimate of toll effect: {:.3f}".format(naive_eff))
print("\nTrue effect (if toll applied to everyone): {:.3f}".format(true_effect))
print("\nBias: {:.3f}".format(naive_eff - true_effect))
print("\nWhy biased? When treated drivers leave, control drivers experience")
print("LESS congestion, so they use the road MORE. This attenuates the")
print("measured difference between treatment and control.")
```

---

## Step 4: Local Experimentation for Tolls

Apply the paper's methodology: **small random perturbations** to individual tolls.

```{python}
# =============================================================================
# STEP 4: Local Experimentation for Toll Sensitivity
# =============================================================================

def local_toll_experimentation(road, base_toll, zeta, trip_values, value_of_time=1.0):
    """
    Local experimentation: perturb individual tolls by small amounts.
    
    Key insight from paper: small perturbations don't meaningfully change
    the equilibrium congestion level, so we can estimate individual toll
    sensitivity without interference bias.
    
    Parameters:
    -----------
    zeta : float
        Magnitude of toll perturbations (should be small, e.g., $0.10)
    
    Returns:
    --------
    delta_hat : float
        Marginal response to toll (how road usage changes per $ of toll)
    """
    n = road.n
    
    # Random perturbations: ε_i ∈ {-1, +1}
    epsilon = np.random.choice([-1, 1], size=n)
    
    # Individual tolls: P_i = p + ζ × ε_i
    tolls = base_toll + zeta * epsilon
    
    # Find equilibrium
    n_on_road = road.capacity // 2
    
    for _ in range(100):
        travel_time = road.travel_time(n_on_road)
        
        uses_road = []
        for i in range(n):
            utility_road = road.driver_utility(trip_values[i], tolls[i], travel_time, value_of_time)
            utility_alt = road.alternative_utility(trip_values[i])
            uses_road.append(1.0 if utility_road >= utility_alt else 0.0)
        
        uses_road = np.array(uses_road)
        new_n = np.sum(uses_road)
        
        if abs(new_n - n_on_road) < 0.5:
            break
        n_on_road = 0.7 * n_on_road + 0.3 * new_n
    
    n_on_road = int(round(n_on_road))
    travel_time = road.travel_time(n_on_road)
    
    Z = np.array(uses_road)  # Road usage decisions
    
    # Regression: estimate Δ by regressing Z on ε
    # Δ_hat = Cov(Z, ε) / Var(ε) / ζ
    Z_centered = Z - np.mean(Z)
    epsilon_centered = epsilon - np.mean(epsilon)
    
    # Note: negative sign because higher toll → LESS usage
    delta_hat = np.sum(Z_centered * epsilon_centered) / np.sum(epsilon_centered**2) / zeta
    
    return delta_hat, n_on_road, travel_time, Z, epsilon

# Run local experimentation
print("Local Experimentation Results:")
print("=" * 50)

zeta_values = [0.05, 0.10, 0.25, 0.50]
base_toll = 5.0

for zeta in zeta_values:
    delta_hat, n_eq, tt_eq, Z, eps = local_toll_experimentation(
        road, base_toll, zeta, trip_values
    )
    print("ζ = ${:.2f}: Δ̂ = {:.4f}, n = {}, T = {:.1f} min".format(
        zeta, delta_hat, n_eq, tt_eq))

print("\nInterpretation: Δ̂ ≈ {:.4f} means a $1 toll increase reduces".format(delta_hat))
print("an individual's road usage probability by {:.1%}".format(abs(delta_hat)))
print("(holding congestion fixed)")
```

---

## Step 5: Converting to True Toll Sensitivity

Account for the **feedback effect**: when tolls go up for everyone, congestion drops, which partially offsets the demand reduction.

```{python}
# =============================================================================
# STEP 5: Converting Marginal Response to True Gradient
# =============================================================================

def compute_true_toll_gradient(delta_hat, n_on_road, road, value_of_time=1.0):
    """
    Convert marginal toll response Δ to true system-wide toll sensitivity Υ.
    
    The feedback effect in congestion pricing:
    - Higher toll → fewer drivers → less congestion
    - Less congestion → road becomes more attractive → some drivers return
    
    This dampens the toll's effect compared to the naive estimate.
    """
    # Get congestion function derivatives
    travel_time = road.travel_time(n_on_road)
    dT_dn = road.travel_time_derivative(n_on_road)  # Marginal congestion
    
    # The feedback factor:
    # When one driver leaves, congestion drops by dT/dn
    # This increases utility for remaining drivers by value_of_time × dT/dn
    # Which causes some to switch back to the road
    
    # Feedback adjustment (analogous to equation 4.2 in paper)
    # In marketplace: feedback through match rate ω
    # In congestion: feedback through travel time T
    
    # If delta < 0 (toll increase → less usage), feedback is positive
    # (less congestion makes road more attractive)
    
    feedback_strength = abs(delta_hat) * value_of_time * dT_dn * n_on_road
    
    # The true effect is dampened by the feedback loop
    upsilon_hat = delta_hat / (1 + feedback_strength)
    
    return upsilon_hat, feedback_strength

# Compute true gradient
delta_hat, n_eq, tt_eq, Z, eps = local_toll_experimentation(
    road, base_toll, zeta=0.10, trip_values=trip_values
)

upsilon_hat, feedback = compute_true_toll_gradient(delta_hat, n_eq, road)

print("Converting Marginal Response to True Gradient:")
print("=" * 50)
print("Marginal response Δ̂ = {:.4f}".format(delta_hat))
print("Feedback strength = {:.4f}".format(feedback))
print("True gradient Υ̂ = {:.4f}".format(upsilon_hat))
print("\nInterpretation:")
print("  |Υ̂| < |Δ̂| because of negative feedback:")
print("  Higher toll → fewer drivers → less congestion → road more attractive")
print("  This partially counteracts the toll's direct effect on demand.")
```

---

## Step 6: Optimizing the Toll

Different objectives lead to different optimal tolls:

```{python}
# =============================================================================
# STEP 6: Optimizing the Toll
# =============================================================================

def compute_social_welfare(road, toll, trip_values, n_on_road=None):
    """
    Compute social welfare = sum of all driver utilities + toll revenue.
    
    Social welfare includes:
    - Consumer surplus (utility for road users)
    - Alternative users' utility
    - Toll revenue (transfers, but matters if used for public good)
    """
    if n_on_road is None:
        n_on_road, travel_time = compute_traffic_equilibrium(road, toll, trip_values)
    else:
        travel_time = road.travel_time(n_on_road)
    
    # Sort by trip value and assume top n_on_road use the road
    sorted_values = np.sort(trip_values)[::-1]
    
    welfare = 0
    
    # Road users: V - toll - travel_time (toll is transfer, not loss)
    for i in range(n_on_road):
        welfare += sorted_values[i] - travel_time
    
    # Alternative users
    for i in range(n_on_road, road.n):
        welfare += road.alternative_utility(sorted_values[i])
    
    return welfare

def optimize_toll(road, trip_values, objective='welfare', n_iterations=25, 
                  learning_rate=0.3, zeta=0.10):
    """
    Optimize toll using local experimentation and gradient descent.
    
    Objectives:
    - 'welfare': maximize social welfare
    - 'revenue': maximize toll revenue
    - 'congestion': minimize total travel time
    """
    toll_history = [3.0]  # Start with $3 toll
    objective_history = []
    
    current_toll = 3.0
    
    for iteration in range(n_iterations):
        # Run local experimentation
        delta_hat, n_eq, tt_eq, Z, eps = local_toll_experimentation(
            road, current_toll, zeta, trip_values
        )
        
        # Convert to true gradient
        upsilon_hat, _ = compute_true_toll_gradient(delta_hat, n_eq, road)
        
        # Compute objective and its gradient
        if objective == 'revenue':
            # Revenue = toll × n_on_road
            current_objective = current_toll * n_eq
            # d(Revenue)/d(toll) = n + toll × dn/dtoll
            gradient = n_eq + current_toll * upsilon_hat * road.n
            
        elif objective == 'welfare':
            current_objective = compute_social_welfare(road, current_toll, trip_values, n_eq)
            # Numerical gradient for welfare (complex analytical form)
            delta_p = 0.1
            obj_plus = compute_social_welfare(road, current_toll + delta_p, trip_values)
            gradient = (obj_plus - current_objective) / delta_p
            
        elif objective == 'congestion':
            # Minimize total travel time
            current_objective = -tt_eq * n_eq  # Negative because we maximize
            gradient = -road.travel_time_derivative(n_eq) * n_eq * upsilon_hat * road.n
            gradient -= tt_eq * upsilon_hat * road.n
        
        # Gradient ascent (maximize objective)
        current_toll = current_toll + learning_rate * gradient / road.n
        current_toll = max(0, min(current_toll, 25))  # Bounds
        
        toll_history.append(current_toll)
        objective_history.append(current_objective)
        
        if iteration % 5 == 0:
            print("Iter {:2d}: toll = ${:.2f}, {} = {:.1f}".format(
                iteration, current_toll, objective, current_objective))
    
    return toll_history, objective_history

# Optimize for different objectives
print("Optimizing Toll for REVENUE:")
print("=" * 50)
toll_hist_rev, _ = optimize_toll(road, trip_values, objective='revenue')

print("\nOptimizing Toll for SOCIAL WELFARE:")
print("=" * 50)
toll_hist_welfare, _ = optimize_toll(road, trip_values, objective='welfare')

print("\nOptimizing Toll to MINIMIZE CONGESTION:")
print("=" * 50)
toll_hist_cong, _ = optimize_toll(road, trip_values, objective='congestion')

print("\n" + "=" * 50)
print("OPTIMAL TOLLS:")
print("  Revenue-maximizing toll: ${:.2f}".format(toll_hist_rev[-1]))
print("  Welfare-maximizing toll: ${:.2f}".format(toll_hist_welfare[-1]))
print("  Congestion-minimizing toll: ${:.2f}".format(toll_hist_cong[-1]))
```

---

## Summary: Key Adaptations for Congestion Pricing

| Paper Concept | Congestion Pricing Adaptation |
|---------------|-------------------------------|
| Match rate $\omega(d/s)$ | Congestion function $T(n)$ (e.g., BPR) |
| Supplier payment $p$ | Toll $p$ (charged, not paid) |
| Outside option | Alternative route/mode utility |
| Supply equilibrium | Wardrop traffic equilibrium |
| Platform profit | Social welfare, revenue, or congestion |
| Marginal response $\Delta$ | Toll elasticity of demand |
| Feedback loop | Less congestion attracts drivers back |

**The policy concern**: [^1]

> If you test a toll on only some drivers, those who stop driving reduce congestion for the untolled drivers, who may then drive *more*. This leads to an **overly optimistic estimate** of the toll's effectiveness at reducing traffic.

The local experimentation approach solves this by using perturbations small enough that they don't meaningfully shift the congestion equilibrium, allowing unbiased estimation of toll sensitivity.
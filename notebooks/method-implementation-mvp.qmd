---
title: "MVP Implementation of Market Equilibrium as Interference"
format:
    html:
        embed-resources: true
---

```{python}
from demo.mvp import (
    # Demand
    GlobalState,
    DemandModel,
    # Allocation
    QueueAllocation,
    LinearAllocation,
    SmoothLinearAllocation,
    # Supplier
    LogisticChoice,
    LogNormalCosts,
    SupplierPopulation,
    # Platform
    LinearRevenue,
    Market
)
import numpy as np
import matplotlib.pyplot as plt
```

# Model of Market

## Overview of Market

The model in the paper describes a centralized marketplace where:

- the platform sets payments to attract suppliers
- suppliers decide whether to become "active" based on expected revenue (relative to their costs)
- demand is randomly allocated among active suppliers
- the platform earns revenue minus payments

## Systematic Assumptions

Unless otherwise stated:
- All random variables are independent across time periods.
- Within a time period, all random variables are independent of one another.
- All variables are implicitly dependent on market size $n$.

## Demand

Demand $D$ is drawn from $D \sim F_a$, where $a$ is a particular global state $A \in \mathbfcal{A}$. Demand scales proportionally with market size (number of potential suppliers?) $n$.

$d_a$ is the expected demand per supplier when the global state is $a$.

As $n$ increases, market behavior can be characterized by deterministic rules as individual supplier randomness averages out, which enables mean-field analysis. Only global randomness from the global state $A$ remains.

### Concentration Property

(3.1):

For all $a \in \mathbfcal{A}$ and $n \in \mathbb{N}$:

$$
\mathbb{E} \left[ \frac{D}{n} | A = a\right] = d_a
\quad \text{and} \quad
\mathop{\lim}_{n \rightarrow \infty} \mathbb{E} \left[ \left( \frac{D}{n} - d_a \right)^2 | A = a \right] = 0
$$

After scaling demand by market size ($\frac{D}{n}$), the variance shrinks to 0 as $n$ grows. In other words, in large markets, expected demand per supplier $d_a$ becomes predictable.

### Tail Property

(3.2):

$\mathbb{P} \left( \frac{D}{n} \notin \left[ \frac{d_a}{2}, 2 d_a \right] | A = a \right) = o \left( \frac{1}{n} \right)$

Rewritten using notation that I find clearer:

$\mathop{\lim}_{n \rightarrow \infty} n \times \mathbb{P} \left( \frac{D}{n} \notin \left[ \frac{d_a}{2}, 2 d_a \right] | A = a \right) = 0$

The probability that scaled demand is greater than $2 d_a$ or less than $\frac{d_a}{2}$ decreases faster than $\frac{1}{n}$. In other words, extreme deviations become exponentially unlikely.

### Demand in Code

```{python}
states = {
    "low_demand": GlobalState("low_demand", d_a=0.3, probability=0.5),
    "high_demand": GlobalState("high_demand", d_a=0.6, probability=0.5),
}

demand_model = DemandModel(states, concentration_param=50)
```

```{python}
print("Testing Concentration Property (Eq. 3.1):")
for n in [1, 10, 100, 1000, 10000, 100000]:
    for state_name, state in states.items():
        print(f'n={n}')
        samples = [demand_model.sample_demand(state, n) / n for _ in range(1000)]
        print(f"  State '{state_name}': d_a = {state.d_a}")
        print(f"    Mean(D/n) = {np.mean(samples):.4f} (should be ≈ {state.d_a})")
        print(f"    Std(D/n) = {np.std(samples):.4f} (should be small)")
    print()
```

## Supply

For each time period:

1. The platform choses a payment distribution $\pi$, draws individual payments $P_i \sim \pi$ (iid), and provides $P_i$ and $\pi$ to all suppliers.
2. Each supplier decides whether or not to join the market. The $i$-th supplier's decision is $Z_i$. The toal number of active suppliers for the time period is $T = \sum_{i = 1}^{n} Z_i$.
3. Demand $D$ is randomly allocated among the $T$ active suppliers.

### Demand per Active Supplier

The expected demand per active supplier with the payment regime $\pi$ is given by:

$\Omega (d, t) = \mathbb{E} [S_i | D = d, T = t]$

where $S_i$ is the amount of demand that the $i$-th supplier serves if active. In equilibrium, all active suppliers have the same expected allocation.

As the market grows large ($n \rightarrow \infty$), we can switch to the mean-field and simplify to:

$\Omega (d, t) = \omega \left( \frac{d}{t} \right) + l(d, t)$

where $\omega \left( \frac{d}{t} \right)$ is a regular allocation function and $l(d, t)$ is an error term that decreases as $d$ and $t$ grow.

Intuitively, allocation per active supplier simplifies to the ratio between demand and the number of active suppliers.

The error function $l$ is bounded:

$| l(d, t) | = o \left( \frac{1}{\sqrt{t}} + \frac{1}{\sqrt{d}} \right)$

#### Defining Regular Allocation Function $\omega$

- Smooth: no sudden jumps
- Concave: the marginal difficultly of matching an additional unit of demand cannot decrease
- Non-decreasing: the more demand per supplier, the more demand each supplier must be allocated
- $\lim_{x \rightarrow 0} \omega(x) = 0$: If there is no demand, suppliers cannot be allocated demand
- $\lim_{x \rightarrow \infty} \omega(x) \leqslant 1$: Suppliers cannot supply more than their capacity
- $\lim_{x \rightarrow 0} \omega'(x) \leqslant 1$[^allocation_bounded_by_demand]: when demand is low relative to supply, the allocation rate cannot grow faster than demand

[^allocation_bounded_by_demand]: The total demand served across all active suppliers is $t \times \omega \left(\frac{d}{t}\right) \leq d$ (total demand served is bounded by total demand). Dividing both sides by $t$ gives us $\omega \left(\frac{d}{t}\right) \leq \frac{d}{t} \leq x$, so we can substitute $x$ into $\omega$ and get $\omega(x) \leqslant x$.

This allows mean-field analysis and capturing all interference in the global statistic $\frac{d}{t}$.

#### Allocation Function in Code

```{python}
print("""
The allocation function ω(x) determines how much demand each active 
supplier serves when the demand-to-supply ratio is x = D/T.

Properties (Definition 5):
- Smooth, concave, non-decreasing
- ω(0) = 0 (no demand → no allocation)
- ω(∞) ≤ 1 (bounded capacity)

Example: Parallel M/M/1 Queues with capacity L
  ω(x) = (x - x^L) / (1 - x^L)
""")

# Create allocation functions
queue_L15 = QueueAllocation(L=15)
queue_L8 = QueueAllocation(L=8)
queue_L4 = QueueAllocation(L=4)
linear = LinearAllocation()

x_vals = np.linspace(0.01, 2.5, 100)

print("Sample values:")
for x in [0.3, 0.5, 1.0, 1.5, 2.0]:
    print(f"  x = {x:.1f}: ω_L8(x) = {queue_L8.omega(x):.4f}, "
          f"ω_L4(x) = {queue_L4.omega(x):.4f}")

# Plot allocation functions
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Allocation function comparison
for L in [4, 8, 15]:
    alloc = QueueAllocation(L=L)
    axes[0].plot(x_vals, [alloc.omega(x) for x in x_vals], label=f'L={L}')
axes[0].plot(x_vals, [linear.omega(x) for x in x_vals], '--', label='Linear')
axes[0].set_xlabel('x = D/T (demand per active supplier)')
axes[0].set_ylabel('ω(x) (allocation per supplier)')
axes[0].set_title('Regular Allocation Functions')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Show derivative (important for equilibrium analysis)
axes[1].plot(x_vals, [queue_L15.omega_derivative(x) for x in x_vals], label='L=15')
axes[1].plot(x_vals, [queue_L8.omega_derivative(x) for x in x_vals], label='L=8')
axes[1].plot(x_vals, [queue_L4.omega_derivative(x) for x in x_vals], label='L=4')
axes[1].set_xlabel('x = D/T')
axes[1].set_ylabel("ω'(x)")
axes[1].set_title('Allocation Function Derivatives')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
```

### Supplier Choice to be Active 

#### Supplier Choice Behavior

(3.6):

Supplier $i$ becoming active is given by:

$$
\mu_{a}^{(n)} (\pi) = \mathbb{P}_{\pi} [Z_i = 1 | A = a] = \mathbb{E} [f_{B_i} (P_i \mathbb{E}_{\pi} [\Omega (D, T) | A = a]) | A = a]
$$

where:

- $T$ is the equilibrium number of active suppliers.
- $\mathbb{E}_{\pi} [\Omega (D, T) | A = a]$ is the expected amount of demand served per provider given the platform's choice of $\pi$.
- $P_i \mathbb{E}_{\pi} [\Omega (D, T) | A = a]$ is the expected revenue of the $i$-th supplier in equilibrium.
- $B_i$ captures the heterogenity across suppliers, such as differents costs or estimated expected revenue. We assume $B_i$ is independently and identically distributed from $\mathbfcal{B}$, which can depend on $A$.
- $f_b(x)$ is the choice function of a supplier becoming active with expected equilibrium revenue $x$ and $B_i = b$. (From assumption 2) $x$ must be $[0, 1]$, the choice function must be monotonically non-decreasing, and must have a uniformly bounded second derivative.

The supplier only considers the average behavior of other marketplace participants when deciding whether or not to enter. This makes their decision stationary, which is required to use the mean-field.

#### Logistic Choice Function

(3.7):

Using the logit model fulfills the requirements for the choice function. Hence our choice function is:

$\mathbb{P}[Z_i = 1 | P_i, \pi, A] = \left( 1 + e^{-\alpha (P_i \mathbb{E}_{\pi} [\Omega (D, T) | A] - B_i)} \right)^{-1}$

where:

- $\alpha > 0$ is a parameter that represents the sensitivity of a supplier's decision to enter to whether or not expected revenue exceeds expected costs. In the limit as $\alpha \rightarrow \infty$, $\mathbb{P}[Z_i = 1 | P_i, \pi, A]$ only returns 0 or 1. In other words, a higher value of $\alpha$ makes the suppliers decision to enter the market deterministic on whether expected revenue > expected costs.
- $B_i$ is supplier $i$'s break-even cost threshold. $B_i$ takes values in $\mathbb{R}_{+}$.

#### Supplier Choice in Code

```{python}
print("""
Suppliers decide to become active based on expected revenue.

Choice model (Eq. 3.6):
  μ_a(π) = E[f_B(P_i * E[Ω(D,T)|A=a]) | A=a]

Logistic choice function (Eq. 3.7):
  P[Z_i = 1] = 1 / (1 + exp(-α(P_i * E[Ω] - B_i)))

Where:
- P_i = payment offered to supplier i
- B_i = supplier i's cost threshold (drawn from distribution)
- α = sensitivity parameter
""")

# Create supplier model
choice_fn = LogisticChoice(alpha=1.0)
cost_dist = LogNormalCosts(log_mean=0.0, log_std=1.0, scale=20.0)
population = SupplierPopulation(choice_fn, cost_dist)

# Show choice function for different cost levels
x_vals = np.linspace(0, 80, 100)
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Choice function f_b(x) for different b values
for b in [10, 20, 30, 40]:
    probs = [choice_fn.f(x, b) for x in x_vals]
    axes[0].plot(x_vals, probs, label=f'b={b}')
axes[0].set_xlabel('Expected Revenue x')
axes[0].set_ylabel('Activation Probability f_b(x)')
axes[0].set_title('Logistic Choice Function (α=1)')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Average activation probability E[f_B(x)]
avg_probs = [population.activation_probability(x) for x in x_vals]
axes[1].plot(x_vals, avg_probs, 'b-', linewidth=2)
axes[1].set_xlabel('Expected Revenue x = p E[Ω]')
axes[1].set_ylabel('Activation Probability μ = E[f_B(x)]')
axes[1].set_title('Population Activation Probability')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()

print("Activation probabilities at different revenue levels:")
for rev in [10, 20, 30, 40, 50]:
    prob = population.activation_probability(rev)
    print(f"  Revenue = {rev}: μ = {prob:.4f}")
print("\nPlot saved to demo_supplier.png")
print()
```

## Platform Utility

(3.8):

The platform's utility is the difference between revenue and payments:

$$
U = R(D, T) - \sum_{i = 1}^{n} P_i Z_i S_i
$$

For each supplier $i$, $P_i Z_i S_i$ is their payment rate times the amount they supplied ($S_i$ if $Z_i = 1$, otherwise 0).

(3.9):

The revenue function $R(D, T)$ is assumed to have the structure:

$$
R(d, t) = \left( r \left( \frac{d}{t} \right) - l(d, t) \right) t
$$

where $r \left( \frac{d}{t} \right)$ is a smooth function with bounded derivatives and $l(d, t)$ is an error function bounded by:

$$
| l(d, t) | = o \left( \frac{1}{\sqrt{t}} + \frac{1}{\sqrt{d}} \right)
$$

$r \left( \frac{d}{t} \right)$ is revenue per supplier.

Intuitively, revenue scales linearly with the number of active suppliers but revenue per supplier depends on the supply-demand ratio.

If the platform receives a fixed payment $\gamma$ per unit of demand served, then $R(D, T) = \gamma (T \Omega(D, T))$.

### Normalized Utility

(3.10):

$$
u_{a}^{(n)}(\pi) = \frac{1}{n} \mathbb{E}_n \left[ U | A = a \right] \quad \text{and} \quad u^{(n)}(\pi) = \mathbb{E}_n \left[ u_{A}^{(n)} (\pi) \right]
$$

The normalized utility is utility divided by market size--utility per supplier. This form is comparable across different market sizes.

### Platform in Code

```{python}
print("""
The equilibrium activation rate μ_a(p) solves:
  μ = E[f_B(p × ω(d_a/μ))]

Platform utility (Eq. 3.8-3.10):
  u_a(p) = (r(d_a/μ) - p×ω(d_a/μ)) × μ

With linear revenue r(x) = γ×ω(x):
  Platform gets γ per unit of demand served
  Pays p per unit of demand to supplier
""")

# Create market
allocation = QueueAllocation(L=8)
gamma = 100  # Platform revenue per unit served
market = Market(allocation, population, gamma)

# Analyze for different demand levels
d_a_values = [0.3, 0.4, 0.5]
payments = np.linspace(5, 60, 50)

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Store results for comparison
results = {}

for d_a in d_a_values:
    utilities = []
    mus = []
    
    for p in payments:
        mu = market.find_equilibrium_mu(d_a, p)
        u = market.mean_field_utility(d_a, p)
        utilities.append(u)
        mus.append(mu)
    
    results[d_a] = {'utilities': utilities, 'mus': mus}
    
    # Find optimal
    opt_idx = np.argmax(utilities)
    
    # Plot utility
    axes[0, 0].plot(payments, utilities, label=f'd_a={d_a}')
    axes[0, 0].scatter([payments[opt_idx]], [utilities[opt_idx]], s=50, zorder=5)
    
    # Plot activation
    axes[0, 1].plot(payments, mus, label=f'd_a={d_a}')

axes[0, 0].set_xlabel('Payment p')
axes[0, 0].set_ylabel('Utility u_a(p)')
axes[0, 0].set_title('Platform Utility vs Payment')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

axes[0, 1].set_xlabel('Payment p')
axes[0, 1].set_ylabel('Activation μ_a(p)')
axes[0, 1].set_title('Equilibrium Activation vs Payment')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# Detailed analysis for d_a = 0.4
d_a = 0.4
print(f"\nDetailed Analysis for d_a = {d_a}:")

utilities = results[d_a]['utilities']
mus = results[d_a]['mus']

opt_idx = np.argmax(utilities)
opt_p = payments[opt_idx]
opt_mu = mus[opt_idx]
opt_u = utilities[opt_idx]

print(f"  Optimal payment: p* = {opt_p:.2f}")
print(f"  Optimal utility: u* = {opt_u:.4f}")
print(f"  Activation at optimum: μ* = {opt_mu:.4f}")

# Compute additional quantities at optimum
x_opt = d_a / opt_mu
q_opt = allocation.omega(x_opt)
print(f"  Demand per active supplier: x* = {x_opt:.4f}")
print(f"  Allocation per supplier: ω(x*) = {q_opt:.4f}")
print(f"  Demand served (fraction): μ*×ω(x*) = {opt_mu * q_opt:.4f}")

# Plot equilibrium quantities
mu_range = np.linspace(0.2, 0.8, 100)
x_range = d_a / mu_range
q_range = [allocation.omega(x) for x in x_range]
demand_served = mu_range * np.array(q_range)

axes[1, 0].plot(payments, [m * allocation.omega(d_a/m) for m in mus], 'b-', linewidth=2)
axes[1, 0].axvline(opt_p, color='r', linestyle='--', alpha=0.5)
axes[1, 0].set_xlabel('Payment p')
axes[1, 0].set_ylabel('Demand Served (μ×ω)')
axes[1, 0].set_title(f'Demand Served vs Payment (d_a={d_a})')
axes[1, 0].grid(True, alpha=0.3)

# Revenue vs cost breakdown
revenues = [gamma * m * allocation.omega(d_a/m) for m in mus]
costs = [payments[i] * mus[i] * allocation.omega(d_a/mus[i]) for i in range(len(payments))]
profits = [r - c for r, c in zip(revenues, costs)]

axes[1, 1].plot(payments, revenues, 'g-', label='Revenue')
axes[1, 1].plot(payments, costs, 'r-', label='Payments')
axes[1, 1].plot(payments, profits, 'b-', label='Profit = Revenue - Payments', linewidth=2)
axes[1, 1].axvline(opt_p, color='k', linestyle='--', alpha=0.5, label=f'Optimal p={opt_p:.1f}')
axes[1, 1].set_xlabel('Payment p')
axes[1, 1].set_ylabel('Per-Supplier Value')
axes[1, 1].set_title(f'Revenue/Cost Breakdown (d_a={d_a})')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
```

# Mean-Field Analysis

As $n$ approaches the mean-field limit (i.e. $n \rightarrow \infty$), the individual/local randomness averages out (think law of large numbers), leaving only global randomness from the state $A$.

The mean-field analysis relies on $n \rightarrow \infty$ for the relevant quantities to converge to limiting functions. For example:

- $\lim_{n \rightarrow \infty} \mu_{a}^{(n)} (p) = \mu_{a} (p)$: In a sufficiently large market, the proportion of suppliers that are active becomes $\mu$ (conditional on global state $A$ and payment $p$)
- $\lim_{n \rightarrow \infty} q_{a}^{(n)} (\mu) = \omega \left( \frac{d_a}{\mu} \right)$: In a sufficiently large market, the demand allocated per active supplier is the demand per supplier divided by the proportion of suppliers that are active
- $\lim_{n \rightarrow \infty} u_{a}^{(n)} (p) = u_{a} (p) = \left( r \left( \frac{d_a}{\mu_a (p)} \right) - p \omega \left( \frac{d_a}{\mu_a (p)} \right) \right) \mu_{a} (p)$: In a sufficiently large market, the platform utility per supplier is the revenue per active supplier minus the payments per active supplier times the proportion of suppliers that are active
- $\lim_{n \rightarrow \infty} (q_{a}^{(n)})' (\mu) = -\omega' \left( \frac{d_a}{\mu} \right) \frac{d_a}{\mu^2}$: allocation derivative?

This makes the important quantities deterministic functions!

Note: $q()$ is the expected demand per supplier if the total number of suppliers was exogeneously drawn as shown: $q_{a}^{(n)}(\mu) = \mathbb{E}[\Omega(D, X)|A = a], \quad X \sim \text{Binomial}(n, \mu)$

# Marginal Response Function

The marginal response function $\triangle (p)$ is the average payment sensitivity of a supplier holding the rest of the market constant.

(3.17): $\triangle_{a}^{(n)}(p) = q_{a}^{(n)} \left( u_{a}^{(n)}(p) \right) \mathbb{E} \left[ f_{B_1}' \left( p q_{a}^{(n)} \left( u_{a}^{(n)}(p) \right) \right) | A = a \right]$

The "true" payment sensitivity, $\frac{d \mu(p)}{d p}$, includes the feedback effects from the market.

(3.18): $\frac{d}{dp}\mu_{a}^{(n)}(p) = \frac{\triangle_{a}^{(n)}(p)}{1 - p \triangle_{a}^{(n)}(p) q_{a}^{(n)'} \left( u_{a}^{(n)}(p) \right) / q_{a}^{(n)} \left( u_{a}^{(n)}(p) \right)} \text{for any } n \geqslant 1$
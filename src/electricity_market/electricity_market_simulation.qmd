---
title: "Electricity Market Simulation: Market Equilibrium as Interference"
#bibliography: "Final Project - Market Equilibrium as Interference.bib"
format:
    html:
        embed-resources: true
    pdf: default
---

```{python}
import numpy as np
```

# Model Components

## Market Participants

### Renewable Generators (Treatment Group)

- Number: $n_{\non} = 100$
- Capacity: $\Capacity_i \sim \Uniform[10,50] \CapacityUnit$
- Operating cost: $c_i \sim \Uniform[30,100] \CostUnit$
- Receives subsidy: $S_i$

### Non-Renewable Generators (Control Group)

- Number: $n_{\ren} = 200$
- Capacity: $\Capacity_j \sim \Uniform[20,100] \CapacityUnit$
- Operating cost: $c_j \sim \Uniform[20,60] \CostUnit$
- No subsidy

### Generate the Market Participants

```{python}
n_ren = 100
n_non = 200

renewables = {
    'capacity': np.random.uniform(10, 50, n_ren),
    'cost': np.random.uniform(30, 100, n_ren)
}

non_renewables = {
    'capacity': np.random.uniform(20, 100, n_non),
    'cost': np.random.uniform(20, 60, n_non)
}
```

## Demand Curve

Daily demand with random context:

$$
\DemandPrice(Q,A) = A \times Q^{-\alpha}
$$

where:

- $A \sim \text{LogNormal}(4.5,0.22)$ is the daily demand shock
- $\alpha = 0.1$ is the demand elasticity
- $Q$ is quantity demanded in MWh

Inverse demand (quantity as function of price):

$$
\DemandQuantity(P, A) = \left( \frac{A}{P} \right)^{\frac{1}{\alpha}}
$$

```{python}
# Demand parameters
alpha = 0.1
mu_A = 4.5
sigma_A = 0.2

def draw_context():
    """Draw daily demand context"""
    return np.random.lognormal(mu_A, sigma_A)

def demand_quantity(price, A, alpha=0.1):
    """Quantity demanded at given price and context"""
    return (A / price) ** (1 / alpha)

def demand_price(quantity, A, alpha=0.1):
    """Inverse demand: price at given quantity"""
    return A * quantity ** (-alpha)
```

## Supply Decisions

- Renewable generator $i$ participation: $Z_i = \mathbb{1} \{ P^* > c_i - S_i \}$
- Renewable generator $i$ supply: $q_i = Z_i \times \Capacity_i$

- Non-renewable generator $j$ participation: $Z_j = \mathbb{1} \{ P^* > c_j \}$
- Non-renewable generator $j$ supply: $q_j = Z_j \times \Capacity_j$

$$
\Supply(P, \{ S_i \}) = \sum_{i = 1}^{n_{\ren}} q_i (P, S_i) + \sum_{i = 1}^{n_{\non}} q_j (P)
$$

```{python}
def compute_supply(price, subsidies, renewables, non_renewables):
    """Compute total supply at given price"""
    # Renewable supply
    effective_cost_ren = renewables['cost'] - subsidies
    ren_participate = price > effective_cost_ren
    Q_ren = np.sum(renewables['capacity'] * ren_participate)

    # Non-renewable supply
    non_participate = price > non_renewables['cost']
    Q_non = np.sum(non_renewables['capacity'] * non_participate)

    Q_total = Q_ren + Q_non

    return Q_total, Q_ren, Q_non
```

## Market Clearing

Find price $P^*$ where supply equals demand: $\Supply(P^*, \{ S_i \}) = \DemandQuantity(P^*, A)$

```{python}
from scipy.optimize import brentq

def find_clearing_price(A, subsidies, renewables, non_renewables, 
                       alpha=0.1, price_bounds=(10, 200)):
    """Find market clearing price"""
    def excess_supply(price):
        Q_supply, _, _ = compute_supply(price, subsidies, renewables, non_renewables)
        Q_demand = demand_quantity(price, A, alpha)
        return Q_supply - Q_demand

    try:
        P_star = brentq(excess_supply, price_bounds[0], price_bounds[1])
    except ValueError:
        # If no equilibrium in range, use boundary
        P_star = price_bounds[0] if excess_supply(price_bounds[0]) < 0 else price_bounds[1]

    return P_star
```

## Treatment Assignment

Baseline subsidy with perturbations:

$S_{it} = s_t + \zeta \epsilon_{it}$

where:

- $s_t$ is the baseline subsidy on day $t$
- $\zeta > 0$ is the perturbation magnitude (small)
- $\epsilon_{it} \sim \Uniform \{ −1,+1 \}$ is the random shock


```{python}
def assign_subsidies(baseline_s, n_generators, zeta=2.0):
    """Assign subsidies with mean-zero perturbations"""
    epsilons = np.random.choice([-1, 1], size=n_generators)
    subsidies = baseline_s + zeta * epsilons
    # Ensure non-negative
    subsidies = np.maximum(subsidies, 0)
    return subsidies, epsilons
```

## Platform Objective

### Maximizing Renewable Generation Minus Costs

$\lambda$ weights the cost of subsidies.

$u_A(s) = \mathbb{E}_{A} [Q_{\ren}(s, A) - \lambda s Q_{\ren}(s, A)] = \mathbb{E}_{A} [Q_{\ren}(s, A) (1 - \lambda s)]$

```{python}
def compute_platform_utility(Q_ren, subsidy_level, lambda_cost=0.5):
    """Platform utility: renewable generation minus subsidy cost"""
    return Q_ren * (1 - lambda_cost * subsidy_level)

def compute_subsidy_cost(Q_ren, subsidy_level):
    """Total subsidy cost"""
    return subsidy_level * Q_ren
```

# Simulation

## One Day

```{python}
def simulate_one_day(t, baseline_s, zeta, renewables, non_renewables, 
                     alpha=0.1, lambda_cost=0.5):
    """
    Simulate one day of market operation

    Returns:
        dict with outcomes: price, quantities, utility, perturbations
    """
    # Draw context
    A_t = draw_context()

    # Assign subsidies with perturbations
    subsidies, epsilons = assign_subsidies(baseline_s, n_ren, zeta)

    # Find market clearing price
    P_star = find_clearing_price(A_t, subsidies, renewables, non_renewables, alpha)

    # Compute quantities at clearing price
    Q_total, Q_ren, Q_non = compute_supply(P_star, subsidies, renewables, non_renewables)

    # Compute utility
    utility = compute_platform_utility(Q_ren, baseline_s, lambda_cost)

    # Record outcomes
    outcomes = {
        'day': t,
        'context': A_t,
        'price': P_star,
        'Q_total': Q_total,
        'Q_renewable': Q_ren,
        'Q_non_renewable': Q_non,
        'baseline_subsidy': baseline_s,
        'subsidies': subsidies,
        'epsilons': epsilons,
        'utility': utility,
        'subsidy_cost': baseline_s * Q_ren
    }

    return outcomes

def simulate_market(T, baseline_s, zeta, renewables, non_renewables,
                   alpha=0.1, lambda_cost=0.5):
    """
    Simulate T days of market operation

    Args:
        T: number of days
        baseline_s: baseline subsidy level ($/MWh)
        zeta: perturbation magnitude
        renewables: dict with 'capacity' and 'cost' arrays
        non_renewables: dict with 'capacity' and 'cost' arrays
        alpha: demand elasticity
        lambda_cost: platform cost weight

    Returns:
        list of daily outcomes
    """
    results = []

    for t in range(T):
        outcome = simulate_one_day(
            t, baseline_s, zeta, renewables, non_renewables,
            alpha, lambda_cost
        )
        results.append(outcome)

    return results
```

## Demonstration

```{python}
simulate_market(10, 10, 0.1, renewables, non_renewables)
```

# Implementing Method

## Translate to Equilibrium Effects via Mean-Field Model

### Estimate Marginal Response Function

From local perturbations, estimate how individual generators respond to subsidy changes.

For renewable generator $i$ on day $t$, the regression model is:

$$
Z_{it} = \beta_0 + \beta_1 \epsilon_{it} + \eta_{it}
$$

where:

- $Z_{it} = 1$ if the generator $i$ participates on day $t$, otherwise 0.
- $\epsilon_{it} \in \{ −1,+1 \}$ is the perturbation
- $\beta_1$ is the marginal response: how participation varies with changes to the subsidy

Weighting by capacity:

$$
\Capacity_i Z_{it} = \beta_0 + \beta_1 \epsilon_{it} + \eta_{it}
$$

gives the marginal change in capacity offered per unit subsidy increase ($\beta_0$).

```{python}
def estimate_marginal_response(results, renewables):
    """
    Estimate marginal response of renewable capacity to subsidies

    Args:
        results: list of daily outcomes from simulation
        renewables: dict with generator characteristics

    Returns:
        beta_1: marginal response coefficient
    """
    # Prepare regression data
    X = []  # perturbations
    Y = []  # capacity-weighted participation

    for outcome in results:
        epsilons = outcome['epsilons']
        subsidies = outcome['subsidies']
        price = outcome['price']

        # Compute participation for each generator
        for i in range(len(renewables['capacity'])):
            effective_cost = renewables['cost'][i] - subsidies[i]
            participates = 1 if price > effective_cost else 0

            X.append(epsilons[i])
            Y.append(renewables['capacity'][i] * participates)

    X = np.array(X)
    Y = np.array(Y)

    # OLS regression: Y = beta_0 + beta_1 * X
    from sklearn.linear_model import LinearRegression
    model = LinearRegression()
    model.fit(X.reshape(-1, 1), Y)

    beta_0 = model.intercept_
    beta_1 = model.coef_[0]

    return beta_1, beta_0
```

### Mean-Field Model

The marginal response $\beta_1$ gives us the response of one generator when they receive a different subsidy. We want to know what happens when all generators receive a different subsidy.

If all generators receive subsidy $s + \triangle s$, total renewable capacity changes by approximately:

$$
\triangle Q_{\ren} \approx n_{\ren} \times \beta_1 \times \frac{\triangle s}{\zeta}
$$

Changing the market clearing price to:

$$
\triangle P^* = \frac{\partial P^*}{\partial \Supply} \times \triangle Q_{\ren}
$$

The change in price feeds back into the equilibrium, causing further changes.

We therefore use the equilibrium gradient:

$\frac{d u_A}{d s} = \frac{\partial u_A}{\partial s} + \frac{\partial u_A}{\partial Q_{\ren}} \times \frac{d Q_{\ren}}{d s}$

where $\frac{d Q_{\ren}}{d s}$ captures the feedback effects of changing the subsidy.

### Computing Price Response

We'll take the derivative of the demand curve $P = A \times Q^{-\alpha}$:

$$
\frac{\partial P}{\partial Q} = -\alpha \times A \times Q^{-\alpha - 1} = -\alpha \times \frac{P}{Q}
$$


```{python}
def compute_price_response(price, quantity, alpha=0.1):
    """
    Compute dP/dQ at current equilibrium

    Args:
        price: current market clearing price
        quantity: current total quantity
        alpha: demand elasticity

    Returns:
        dP_dQ: price response to quantity change
    """
    return -alpha * price / quantity

```

### Computing Equilibrium Quantity Response

The direct effect on capacity of increasing the subsidy by $\triangle s$ for all renewable generators is:

$$
\triangle Q_{\ren}^{\text{direct}} = n_{\ren} \times \beta_1 \times \frac{\triangle s}{\zeta}
$$

This increase in supply reduces the price by

$$
\triangle P = \frac{\partial P}{\partial Q} \times \triangle Q_{\ren}^{\text{direct}}
$$

Lowering the price causes some generators to opt out of the market. The net effect is determined by the slope of the supply curve.

With many generators (with different costs), the equilibrium quantity response is approximately:

$$
\frac{d Q_{\ren}}{d s} \approx \frac{n_{\ren} \times \frac{\beta_1}{\zeta}}{1 - \frac{\partial P}{\partial Q} \times \frac{\partial \Supply}{\partial P}}
$$

The denominator is the strength of the feedback.

```{python}
def compute_equilibrium_response(beta_1, n_ren, zeta, price, quantity, 
                                renewables, non_renewables, alpha=0.1):
    """
    Compute equilibrium dQ_ren/ds accounting for price feedback

    Args:
        beta_1: marginal response from regression
        n_ren: number of renewable generators
        zeta: perturbation magnitude
        price: current clearing price
        quantity: current total quantity
        renewables, non_renewables: generator characteristics
        alpha: demand elasticity

    Returns:
        dQ_ren_ds: equilibrium renewable quantity response to subsidy
    """
    # Direct effect
    direct_effect = n_ren * beta_1 / zeta

    # Price response to quantity change
    dP_dQ = compute_price_response(price, quantity, alpha)

    # Supply response to price (density of generators at margin)
    # Approximate by counting generators near the clearing price
    margin_width = 5.0  # $/MWh window

    # Renewable generators at margin
    ren_at_margin = np.sum(
        (renewables['cost'] > price - margin_width) & 
        (renewables['cost'] < price + margin_width)
    )
    ren_capacity_at_margin = np.sum(
        renewables['capacity'] * 
        ((renewables['cost'] > price - margin_width) & 
         (renewables['cost'] < price + margin_width))
    )

    # Non-renewable generators at margin
    non_at_margin = np.sum(
        (non_renewables['cost'] > price - margin_width) & 
        (non_renewables['cost'] < price + margin_width)
    )
    non_capacity_at_margin = np.sum(
        non_renewables['capacity'] * 
        ((non_renewables['cost'] > price - margin_width) & 
         (non_renewables['cost'] < price + margin_width))
    )

    # Approximate supply slope
    dQ_dP = (ren_capacity_at_margin + non_capacity_at_margin) / margin_width

    # Feedback coefficient
    feedback = dP_dQ * dQ_dP

    # Equilibrium response
    if feedback < 0.99:  # Stable equilibrium
        dQ_ren_ds = direct_effect / (1 - feedback)
    else:  # Nearly unstable, use direct effect only
        dQ_ren_ds = direct_effect

    return dQ_ren_ds
```

### Platform Utility Gradient

#### Maximizing Renewable Generation Minus Costs

The platform utility is $u_A(s) = Q_{\ren}(s, A) (1 - \lambda s)$

The gradient of the utility is:

$$
\frac{d u_A}{d s} = \frac{d Q_{\ren}}{d s} (1 - \lambda s) - \lambda Q_{\ren}
$$

```{python}
def compute_utility_gradient(Q_ren, dQ_ren_ds, subsidy, lambda_cost=0.5):
    """
    Compute gradient of platform utility with respect to subsidy

    Args:
        Q_ren: current renewable generation
        dQ_ren_ds: equilibrium response dQ_ren/ds
        subsidy: current subsidy level
        lambda_cost: platform cost weight

    Returns:
        gradient: du/ds
    """
    # Gradient of utility
    grad = (1 - lambda_cost * subsidy) * dQ_ren_ds - lambda_cost * Q_ren

    return grad
```

### Gradient Estimation for One Period

```{python}
def estimate_gradient(results, renewables, non_renewables, 
                     baseline_s, zeta, lambda_cost=0.5, alpha=0.1):
    """
    Estimate gradient of platform utility at current subsidy level

    Args:
        results: list of daily outcomes
        renewables, non_renewables: generator characteristics
        baseline_s: current baseline subsidy
        zeta: perturbation magnitude
        lambda_cost: platform cost weight
        alpha: demand elasticity

    Returns:
        gradient: estimated du/ds at baseline_s
    """
    # Step 1: Estimate marginal response
    beta_1, beta_0 = estimate_marginal_response(results, renewables)

    # Step 2: Compute average equilibrium values
    avg_price = np.mean([r['price'] for r in results])
    avg_Q_total = np.mean([r['Q_total'] for r in results])
    avg_Q_ren = np.mean([r['Q_renewable'] for r in results])

    # Step 3: Compute equilibrium response
    dQ_ren_ds = compute_equilibrium_response(
        beta_1, len(renewables['capacity']), zeta,
        avg_price, avg_Q_total, renewables, non_renewables, alpha
    )

    # Step 4: Compute utility gradient
    gradient = compute_utility_gradient(
        avg_Q_ren, dQ_ren_ds, baseline_s, lambda_cost
    )

    return gradient, {
        'beta_1': beta_1,
        'beta_0': beta_0,
        'dQ_ren_ds': dQ_ren_ds,
        'avg_Q_ren': avg_Q_ren,
        'avg_price': avg_price
    }
```

## Gradient Ascent

The Wager and Xu algorithm updates the baseline subsidy after each batch of observations.

The simple version of the update rule is:

$s_{t + 1} = \text{proj}_{[s_{\min}, s_{\max}]} ( s_t + \eta \hat{\Gamma}_t )$

where:

- $s_t$ is the baseline subsidy at timepoint $t$
- $\eta > 0$ is the step size
- $\hat{\Gamma}_t$ is the estimated gradient
- $\text{proj}$ projects onto feasible set (of subsidies?)

The paper has a better version that uses weighted history to stabilize:

$s_{t + 1} = \mathop{\arg \min}_{s \in [s_{\min}, s_{\max}]} \left\{ \frac{1}{2 \eta} \sum_{k = 1}^{t} k (s - s_k)^2 - \theta_t(s) \right\}$

where $\theta_t(s) = \sum_{k = 1}^{t} k \hat{\Gamma}_k s$, which simplifies to:

$s_{t + 1} = \text{proj}_{[s_{\min}, s_{\max}]} \left( \frac{\sum_{k = 1}^{t} k (s_k + \eta \hat{\Gamma}_k)}{\sum_{k = 1}^{t} k} \right)$

```{python}
def project_subsidy(s, s_min=0.0, s_max=50.0):
    """Project subsidy onto feasible range"""
    return np.clip(s, s_min, s_max)

def gradient_ascent_update_simple(s_current, gradient, eta=0.5, 
                                 s_min=0.0, s_max=50.0):
    """
    Simple gradient ascent update

    Args:
        s_current: current subsidy level
        gradient: estimated gradient
        eta: step size
        s_min, s_max: feasible subsidy range

    Returns:
        s_next: updated subsidy level
    """
    s_next = s_current + eta * gradient
    s_next = project_subsidy(s_next, s_min, s_max)
    return s_next

def gradient_ascent_update_weighted(history_s, history_gradients, eta=0.5,
                                   s_min=0.0, s_max=50.0):
    """
    Weighted gradient ascent update (Wager & Xu style)

    Args:
        history_s: list of past subsidy levels
        history_gradients: list of past gradient estimates
        eta: step size
        s_min, s_max: feasible subsidy range

    Returns:
        s_next: updated subsidy level
    """
    T = len(history_s)

    # Compute weights (linear weighting: k = 1, 2, ..., T)
    weights = np.arange(1, T + 1)

    # Weighted average with gradient adjustment
    numerator = np.sum(weights * (np.array(history_s) + eta * np.array(history_gradients)))
    denominator = np.sum(weights)

    s_next = numerator / denominator
    s_next = project_subsidy(s_next, s_min, s_max)

    return s_next
```

## Complete Learning Alogorithm

```{python}
def learn_optimal_subsidy(renewables, non_renewables,
                         T_total=500,  # Total days
                         batch_size=50,  # Days per batch
                         s_init=20.0,  # Initial subsidy
                         zeta=2.0,  # Perturbation size
                         eta=0.5,  # Step size
                         s_min=0.0,  # Min subsidy
                         s_max=50.0,  # Max subsidy
                         lambda_cost=0,  # Cost weight
                         alpha=0.1):  # Demand elasticity
    """
    Learn optimal subsidy via online gradient ascent

    Args:
        renewables, non_renewables: generator characteristics
        T_total: total number of days to simulate
        batch_size: days per gradient estimation batch
        s_init: initial subsidy level
        zeta: perturbation magnitude
        eta: gradient ascent step size
        s_min, s_max: feasible subsidy range
        lambda_cost: platform cost weight
        alpha: demand elasticity

    Returns:
        learning_history: dict with subsidies, gradients, utilities over time
    """
    n_batches = T_total // batch_size

    # Initialize
    s_current = s_init
    history_s = []
    history_gradients = []
    history_utilities = []
    history_Q_ren = []

    print(f"Starting learning with {n_batches} batches of {batch_size} days each")
    print(f"Initial subsidy: ${s_current:.2f}/MWh\n")

    for batch in range(n_batches):
        print(f"Batch {batch + 1}/{n_batches}: Testing subsidy s = ${s_current:.2f}/MWh")

        # Simulate batch_size days at current subsidy
        results = simulate_market(
            T=batch_size,
            baseline_s=s_current,
            zeta=zeta,
            renewables=renewables,
            non_renewables=non_renewables,
            alpha=alpha,
            lambda_cost=lambda_cost
        )

        # Estimate gradient
        gradient, diagnostics = estimate_gradient(
            results, renewables, non_renewables,
            s_current, zeta, lambda_cost, alpha
        )

        # Compute average utility achieved
        avg_utility = np.mean([r['utility'] for r in results])
        avg_Q_ren = diagnostics['avg_Q_ren']

        # Store history
        history_s.append(s_current)
        history_gradients.append(gradient)
        history_utilities.append(avg_utility)
        history_Q_ren.append(avg_Q_ren)

        # Print diagnostics
        print(f"  Avg renewable generation: {avg_Q_ren:.1f} MWh")
        print(f"  Avg utility: {avg_utility:.2f}")
        print(f"  Estimated gradient: {gradient:.3f}")
        print(f"  Marginal response β₁: {diagnostics['beta_1']:.3f}")
        print(f"  Equilibrium response dQ/ds: {diagnostics['dQ_ren_ds']:.3f}")

        # Update subsidy (weighted gradient ascent)
        s_next = gradient_ascent_update_weighted(
            history_s, history_gradients, eta, s_min, s_max
        )

        print(f"  → Next subsidy: ${s_next:.2f}/MWh\n")

        s_current = s_next

    return {
        'subsidies': history_s,
        'gradients': history_gradients,
        'utilities': history_utilities,
        'Q_renewable': history_Q_ren,
        'final_subsidy': s_current
    }
```

# Demo

```{python}
# Set random seed
np.random.seed(42)

# Initialize generators
n_ren = 100
n_non = 200

renewables = {
    'capacity': np.random.uniform(10, 50, n_ren),
    'cost': np.random.uniform(30, 90, n_ren)
}

non_renewables = {
    'capacity': np.random.uniform(20, 100, n_non),
    'cost': np.random.uniform(20, 60, n_non)
}

# Run learning algorithm
learning_history = learn_optimal_subsidy(
    renewables=renewables,
    non_renewables=non_renewables,
    T_total=500,  # 500 days total
    batch_size=1,  # 50 days per batch → 10 updates
    s_init=20.0,  # Start at $20/MWh
    zeta=2.0,  # $2 perturbations
    eta=0.5,  # Step size
    s_min=0.0,
    s_max=50.0,
    lambda_cost=0.05,
    alpha=0.1
)

print("\n" + "="*50)
print("LEARNING COMPLETE")
print("="*50)
print(f"Final optimal subsidy: ${learning_history['final_subsidy']:.2f}/MWh")
print(f"Initial subsidy: $20.00/MWh")
print(f"Change: ${learning_history['final_subsidy'] - 20.0:.2f}/MWh")
```

```{python}
import matplotlib.pyplot as plt

def plot_learning_results(learning_history):
    """Plot learning progress"""
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))

    batches = np.arange(1, len(learning_history['subsidies']) + 1)

    # Subsidy over time
    axes[0, 0].plot(batches, learning_history['subsidies'], 'o-', linewidth=2)
    axes[0, 0].set_xlabel('Batch')
    axes[0, 0].set_ylabel('Subsidy ($/MWh)')
    axes[0, 0].set_title('Subsidy Learning Path')
    axes[0, 0].grid(True, alpha=0.3)

    # Utility over time
    axes[0, 1].plot(batches, learning_history['utilities'], 'o-', 
                    linewidth=2, color='green')
    axes[0, 1].set_xlabel('Batch')
    axes[0, 1].set_ylabel('Platform Utility')
    axes[0, 1].set_title('Platform Utility Over Time')
    axes[0, 1].grid(True, alpha=0.3)

    # Renewable generation over time
    axes[1, 0].plot(batches, learning_history['Q_renewable'], 'o-',
                    linewidth=2, color='orange')
    axes[1, 0].set_xlabel('Batch')
    axes[1, 0].set_ylabel('Renewable Generation (MWh)')
    axes[1, 0].set_title('Renewable Generation Over Time')
    axes[1, 0].grid(True, alpha=0.3)

    # Gradient over time
    axes[1, 1].plot(batches, learning_history['gradients'], 'o-',
                    linewidth=2, color='red')
    axes[1, 1].axhline(y=0, color='black', linestyle='--', alpha=0.5)
    axes[1, 1].set_xlabel('Batch')
    axes[1, 1].set_ylabel('Gradient (du/ds)')
    axes[1, 1].set_title('Gradient Estimates Over Time')
    axes[1, 1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# Plot results
plot_learning_results(learning_history)
```
# Markets as Interference: Experimenting in Equilibrium

Implements [*Experimenting in Equilibrium* by Stefen Wager and Kuang Xu](https://doi.org/10.48550/arXiv.1903.02124)

The method implementation is in `src/demo/method/`.

The simulations are in `src/demo/simulations`.

Figures are generated by the scripts in `src/demo/figures`.

## Docs

[Documentation](docs/index.html)

I generate documentation using MkDocs from the docstrings in demo. The docs are stored in `docs/`.

This process uses MathJax to render LaTeX math expressions from docstrings (written inline with `$...$` and in display mode with `$$...$$`).

`scripts/build_docs.py` automatically adds all modules in `src/demo/method/` to the documentation.

`docsrc/` contains the configuration for the docs. `mkdocs.yml` is automatically generated--use `mkdocs_config.yml`.

The documentation dependencies can be installed with `uv sync --group docs`.

The generation of the docs is part of a GitHub Actions workflow (`.github/workflows/docs.yml`).

You can serve the documentation with live reload of the already-discovered modules with:

``` bash
uv run mkdocs serve
```

Then open http://127.0.0.1:8000 in your browser.

## Short-Term Fix for `uv`

For whatever reason, `uv` will sometimes only install `demo` if `pyproject.toml` has been saved very recently. When this is happening, I get `ModuleNotFoundError`s when importing `demo` inside scripts called by `uv run`. I have spent a lot of time digging into this and have not been able to find the root cause. The intermittency makes it very challenging to diagnose.

The short-term solution is to to use the following:

``` bash
# Before using console
touch pyproject.toml && uv sync
# Instead of `uv run`
touch pyproject.toml && uv run
```

`scripts/diagnose_modulenotfound_error.py` checks that this fixes the `ModuleNotFoundError`.

## TODOs

-   [ ] Refactor ExperimentParams to work with all three learning algorithms AND separate out the algorithm specific stuff to minimize the amount of copy-pasting.
-   [ ] Figure showing supplier choice function behavior as $B_i$ and $P_i$ change
-   [ ] Write a function $p^*$ and then optioanlly add to figures
-   [ ] Create public facing wrapper classes
-   [ ] Standardize the variable names. I am thinking the "math" names for the internal functions and dataclasses (eg $\mu$) and proper names for the wrappers (eg prop_active). Could also support both via overloading. Unsure how Pythonic that is.
-   [ ] Implement the other two bandits (thompson and UBC)
-   [ ] Simulate how close to mean field various market sizes are
-   [ ] Try getting the congestion pricing example working now that I have the method itself working
-   [ ] Try getting the renewable energy subsidy working now that I have the method itself working